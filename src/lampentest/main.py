# TODO: Nachschauen, ob Lampen schon in der Datenbank sind
# TODO: Fortschrittseingabe auf Seite Anzahl Prüfungen

import json
import sys
import time

from calculations.calc_input_widgets import set_max_font_size_label_filepath
import gpio
from label_print.label import print_label
from light_test.light_capture import light_capture
from log.protocol import Protocol
from PyQt5.QtCore import QCoreApplication, QSettings
from PyQt5.QtGui import QFont
from PyQt5.QtWidgets import QApplication
from settings import AUTO_LOGOUT, LIGHT_SETTINGS_CONFIG_PATH, PI, THRESHOLD_INTENSITY
from ui.article_selection import UiArticleSelection
from ui.business_order_selection import UiBusinessOrderSelection
from ui.check import UiCheck
from ui.close_cover import UiCloseCover
from ui.error import UiError
from ui.main_window import UiMainWindow
from ui.open_cover import UiOpenCover
from ui.quantity_selection import UiQuantitySelection
from ui.tool_change import UiToolChange
from ui.user_login import UiUserLogin

settings = QSettings("Bilton", "Lampentest")


class LightTester:
    def __init__(self) -> None:
        with open(LIGHT_SETTINGS_CONFIG_PATH) as lightSettingsFile:  # noqa: PTH123
            self.light_settings = json.load(lightSettingsFile)
        self.active_article_number = ""
        self.active_article_data = {}
        self.current_user = ""
        self.test_counter = 1
        self.test_quantity = 9999
        self.business_order = ""

        self.close_to_exit = False
        self.loop_flag = True

        self.protocol = Protocol()

    def start(self):
        gpio.init()

        self.app = QApplication(sys.argv)  # create app

        # create main window
        self.main_window = UiMainWindow()
        # create page open_cover
        self.open_cover = UiOpenCover()
        self.main_window.addWidget(self.open_cover)
        # create page user_login
        self.user_login = UiUserLogin()
        self.main_window.addWidget(self.user_login)
        # create page business_order_selection
        self.business_order_selection = UiBusinessOrderSelection()
        self.main_window.addWidget(self.business_order_selection)
        # create page article_selection
        self.article_selection = UiArticleSelection()
        self.main_window.addWidget(self.article_selection)
        # create page tool_change
        self.tool_change = UiToolChange()
        self.main_window.addWidget(self.tool_change)
        # create page quantity_selection
        self.quantity_selection = UiQuantitySelection()
        self.main_window.addWidget(self.quantity_selection)
        # create page close_cover
        self.close_cover = UiCloseCover()
        self.main_window.addWidget(self.close_cover)
        # create page check
        self.check = UiCheck()
        self.main_window.addWidget(self.check)
        # create page error
        self.error = UiError()
        self.main_window.addWidget(self.error)

        # button signals
        self.open_cover.pushButton_cancel.clicked.connect(self.cancel_open_cover)
        self.user_login.pushButton_confirm.clicked.connect(self.confirm_user_login)
        self.user_login.pushButton_exit.clicked.connect(self.exit_app)
        self.business_order_selection.pushButton_confirm.clicked.connect(
            self.confirm_business_order_selection
        )
        self.business_order_selection.pushButton_logout.clicked.connect(self.logout)
        self.article_selection.pushButton_confirm.clicked.connect(self.confirm_article_selection)
        self.article_selection.pushButton_logout.clicked.connect(self.logout)
        self.tool_change.pushButton_confirm.clicked.connect(self.confirm_tool_change)
        self.quantity_selection.pushButton_logout.clicked.connect(self.logout)
        self.quantity_selection.pushButton_confirm.clicked.connect(self.confirm_quantity_selection)
        self.error.pushButton_retry.clicked.connect(self.retry_test)
        self.error.pushButton_openCover.clicked.connect(self.open_cover_after_error)

        # load settings
        value = settings.value("filepath")
        if value is not None:
            self.user_login.label_filepath.setText(str(value))
            font = QFont()
            font.setPointSize(set_max_font_size_label_filepath(self.user_login.label_filepath))
            self.user_login.label_filepath.setFont(font)
        else:
            self.user_login.choose_filepath()

        # show main window
        if PI:
            self.main_window.showFullScreen()
        else:
            self.main_window.show()

        self.start_open_cover()

        # execute app
        self.app.exec()

    def light_turned_off(self):
        # if first value of tuple light_caputre is < 1000 return true
        # get self.intensity from file at article number
        light_capture_result = light_capture()
        if light_capture_result == (-1, -1):
            self.show_error("port_not_found")
        elif light_capture_result == (-2, -2):
            self.show_error("capture")
        return light_capture_result[0] < THRESHOLD_INTENSITY

    def retry_test(self):
        self.main_window.setCurrentWidget(self.check)
        QApplication.processEvents()
        self.start_check()

    def open_cover_after_error(self):
        self.test_counter = -1
        self.start_open_cover()

    # function for open cover
    def start_open_cover(self):
        self.main_window.setCurrentWidget(self.open_cover)
        QApplication.processEvents()
        gpio.open_lock()
        gpio.yellow_light_on()
        gpio.activate_daylight()
        pause_end = time.time()
        opening_time = 25 if PI else 5
        time_stored = 0
        time_passed = 0
        while time_passed <= opening_time and self.loop_flag is True:
            time_passed = time.time() + time_stored - pause_end
            gpio.open_cover()
            if self.open_cover.pushButton_interrupt.isChecked():
                time_stored = time_passed
                while self.open_cover.pushButton_interrupt.isChecked() and self.loop_flag is True:
                    gpio.cover_stop()
                    QCoreApplication.processEvents()
                pause_end = time.time()

            QCoreApplication.processEvents()

        self.open_cover.pushButton_interrupt.setChecked(False)
        self.loop_flag = True

        gpio.cover_stop()

        if self.test_counter == 1 or AUTO_LOGOUT:
            self.main_window.setCurrentWidget(self.user_login)
            self.user_login.lineEdit_userInput.setFocus()
        elif self.test_counter > self.test_quantity or self.test_counter == -1:
            self.main_window.setCurrentWidget(self.business_order_selection)
        else:
            self.start_close_cover()

    # function for cancel button on page open_cover
    def cancel_open_cover(self):
        self.loop_flag = False

    # function for confirm button on page user_login
    def confirm_user_login(self):
        user_id = self.user_login.lineEdit_userInput.text()
        user_id = user_id.upper()
        self.user_login.lineEdit_userInput.clear()
        if not user_id.isalpha() or len(user_id) != 4:
            self.user_login.label_text2.show()
            self.user_login.lineEdit_userInput.setFocus()
            return
        self.user_login.label_text2.hide()
        self.current_user = user_id

        self.main_window.setCurrentWidget(self.business_order_selection)
        self.business_order_selection.lineEdit_userInput.setFocus()

    def confirm_business_order_selection(self):
        business_order = self.business_order_selection.lineEdit_userInput.text()
        self.business_order_selection.lineEdit_userInput.clear()
        # check if business order is 10 digit integer
        if not business_order.isnumeric() or len(business_order) != 10:
            self.business_order_selection.label_text2.show()
            self.business_order_selection.lineEdit_userInput.setFocus()
            return
        self.business_order_selection.label_text2.hide()

        self.business_order = business_order
        self.main_window.setCurrentWidget(self.article_selection)
        self.article_selection.lineEdit_userInput.setFocus()

    def confirm_article_selection(self):
        # article number should contain 9 characters (8 numbers and _ on index 6)
        article_number = self.article_selection.lineEdit_userInput.text()
        self.article_selection.lineEdit_userInput.clear()
        if (
            len(article_number) != 9
            or article_number[6] != "_"
            or not article_number[:6].isnumeric()
            or not article_number[7:].isnumeric()
        ):
            self.article_selection.label_text2.show()
            self.article_selection.lineEdit_userInput.setFocus()
            return
        self.article_selection.label_text2.hide()

        self.active_article_number = article_number

        if article_number not in self.light_settings:
            self.article_selection.label_text2.show()
            self.article_selection.lineEdit_userInput.setFocus()
            return
        self.article_selection.label_text2.hide()
        new_tool = self.light_settings[article_number]["Tool"]
        self.active_article_data = self.light_settings[article_number]

        # open protocol.csv and check this business order-article number-combination is already in protocol
        filepath = settings.value("filepath")
        with open(f"{filepath}/protokoll.csv") as protocol_file:  # noqa: PTH123
            protocol_file.readline()
            for line in protocol_file:
                if (
                    line.split(";")[3] == self.business_order
                    and line.split(";")[4] == self.active_article_number
                ):
                    # if number of last test is smaller than quantity
                    if int(line.split(";")[6]) < int(line.split(";")[7]):
                        # set self.quantity_selection.lineEdit1_userInput to last number + 1
                        self.quantity_selection.lineEdit1_userInput.setText(
                            str(int(line.split(";")[6]) + 1)
                        )
                        self.quantity_selection.lineEdit1_userInput.setReadOnly(False)
                        # set self.quantity_selection.lineEdit2_userInput to last quantity
                        self.quantity_selection.lineEdit2_userInput.setText(line.split(";")[7])
                        # make self.quantity_selection.lineEdit2_userInput uneditable
                        self.quantity_selection.lineEdit2_userInput.setReadOnly(True)
                else:
                    # set self.quantity_selection.lineEdit1_userInput to 1
                    self.quantity_selection.lineEdit1_userInput.setText("1")
                    self.quantity_selection.lineEdit1_userInput.setReadOnly(False)
                    # make self.quantity_selection.lineEdit2_userInput editable
                    self.quantity_selection.lineEdit2_userInput.setReadOnly(False)

        # if tool is not equal to current tool show popup
        old_tool = settings.value("current_tool")
        if old_tool != new_tool:
            self.tool_change.label_text2.setText(f"von {old_tool} zu {new_tool}")
            self.main_window.setCurrentWidget(self.tool_change)

        else:
            self.main_window.setCurrentWidget(self.quantity_selection)
            self.quantity_selection.lineEdit1_userInput.setFocus()

    def confirm_tool_change(self):
        # save new tool in settings and save tool change in protocol
        new_tool = self.tool_change.label_text2.text().split(" ")[-1]
        self.protocol.save_tool_change(self.current_user, settings.value("current_tool"), new_tool)
        self.main_window.setCurrentWidget(self.quantity_selection)
        self.quantity_selection.lineEdit1_userInput.setFocus()

    def confirm_quantity_selection(self):
        if (
            self.quantity_selection.active_lineedit == self.quantity_selection.lineEdit1_userInput
            and not self.quantity_selection.lineEdit2_userInput.isReadOnly()
        ):
            self.quantity_selection.lineEdit2_userInput.setFocus()
        else:
            # quantity should be an integer between 1 and 9999
            test_counter = self.quantity_selection.lineEdit1_userInput.text()
            quantity = self.quantity_selection.lineEdit2_userInput.text()
            self.quantity_selection.lineEdit1_userInput.clear()
            self.quantity_selection.lineEdit2_userInput.clear()
            if (
                not (test_counter.isnumeric() and quantity.isnumeric())
                or int(test_counter) < 1
                or int(quantity) < 1
                or int(test_counter) > 9999
                or int(quantity) > 9999
            ):
                self.quantity_selection.label_text2.setText(
                    "Bitte geben Sie eine gültige Stückzahl zwischen 1 und 9999 ein!"
                )
                self.quantity_selection.label_text2.show()
                self.quantity_selection.lineEdit1_userInput.setFocus()
                if self.quantity_selection.lineEdit2_userInput.isReadOnly():
                    self.quantity_selection.lineEdit2_userInput.setText(quantity)
                return
            if int(test_counter) > int(quantity):
                self.quantity_selection.label_text2.setText(
                    "Die Stückzahl der Lampe kann höchstens der Gesamtanzahl entsprechen!"
                )
                self.quantity_selection.label_text2.show()
                self.quantity_selection.lineEdit1_userInput.setFocus()
                if self.quantity_selection.lineEdit2_userInput.isReadOnly():
                    self.quantity_selection.lineEdit2_userInput.setText(quantity)
                return

            self.test_counter = int(test_counter)
            self.test_quantity = int(quantity)

            self.quantity_selection.label_text2.hide()
            self.start_close_cover()

    def start_close_cover(self):
        self.main_window.setCurrentWidget(self.close_cover)
        QApplication.processEvents()
        gpio.close_lock()
        while not gpio.lock_engaged():
            QApplication.processEvents()
            while self.close_cover.pushButton_confirm.isChecked():
                gpio.close_cover()
                QCoreApplication.processEvents()
                if gpio.lock_engaged():
                    break

            if not self.close_cover.pushButton_confirm.isChecked():
                gpio.cover_stop()
                self.close_cover.pushButton_confirm.setChecked(False)
                QCoreApplication.processEvents()

        if gpio.lock_engaged():
            time.sleep(1)
            gpio.cover_stop()
            QCoreApplication.processEvents()
            if not gpio.safety_check():
                self.show_error("safety_circuit")

            if self.close_to_exit is True:
                gpio.cleanup()
                self.app.quit()

            else:
                self.check.label_text2.setText(
                    f"Prüfung {self.test_counter} von {self.test_quantity}"
                )
                self.main_window.setCurrentWidget(self.check)
                self.start_check()

                QCoreApplication.processEvents()

    def normal_check(self):
        gpio.activate_main_voltage()
        time.sleep(int(self.active_article_data["Wartezeit_Initialisierung"]))  # initial wait time

        time.sleep(1)

        # 3x check if light is turned on
        turned_on = False
        for _ in range(3):
            if not self.light_turned_off():
                turned_on = True
                break
        if turned_on is False:
            self.show_error("no_activation")
        else:
            self.check.progressBar.setProperty("value", 25)
            QApplication.processEvents()

        gpio.deactivate_voltage()

    def ms_check(self):
        gpio.activate_main_voltage()
        time.sleep(int(self.active_article_data["Wartezeit_Initialisierung"]))  # initial wait time

        # 3x check if light is turned off
        turned_off = False
        for _ in range(3):
            if self.light_turned_off():
                turned_off = True
                break
        if turned_off is False:
            self.show_error("early_activation")
        else:
            self.check.progressBar.setProperty("value", 15)
            QApplication.processEvents()

        time.sleep(1)

        # turn motion sensor servo and check if light is turned on 3x
        gpio.turn_motion_sensor_servo()
        turned_on = False
        for _ in range(3):
            if not self.light_turned_off():
                turned_on = True
                break
        if turned_on is False:
            self.show_error("late_activation")
        else:
            self.check.progressBar.setProperty("value", 20)
            QApplication.processEvents()

        # wait for light to turn off and count passed time 3x
        early_deactivation = False
        late_deactivation = False
        for _ in range(3):
            start_time = time.time()
            ausschaltzeit = int(self.active_article_data["Ausschaltzeit_Bewegungsmelder"])
            while not self.light_turned_off():
                pass
            self.time_passed = time.time() - start_time
            print(self.time_passed)
            if ausschaltzeit - 2 > self.time_passed:
                early_deactivation = True
            elif ausschaltzeit + 2 < self.time_passed:
                late_deactivation = True
            else:
                break
        if early_deactivation is True:
            self.show_error("early_deactivation")
        elif late_deactivation is True:
            self.show_error("late_deactivation")
        else:
            self.check.progressBar.setProperty("value", 50)
            QApplication.processEvents()

        time.sleep(1)

        # daylight sensor check
        # turn motion sensor servo and check if light is turned on 3x
        gpio.activate_daylight()
        time.sleep(int(self.active_article_data["Tageslicht_Wartezeit"]))
        gpio.turn_motion_sensor_servo()

        # 3x check if light is turned off
        turned_off = False
        for _ in range(3):
            if self.light_turned_off():
                turned_off = True
                break
        if turned_off is False:
            self.show_error("daylight_deactivation")
        else:
            self.check.progressBar.setProperty("value", 60)
            QApplication.processEvents()

        gpio.deactivate_daylight()

        time.sleep(1)

        gpio.turn_motion_sensor_servo()

        # 3x check if light is turned on
        turned_on = False
        for _ in range(3):
            if not self.light_turned_off():
                turned_on = True
                break
        if turned_on is False:
            self.show_error("after_daylight_activation")
        else:
            self.check.progressBar.setProperty("value", 70)
            QApplication.processEvents()

        gpio.deactivate_voltage()

    def emergency_light_check(self):
        # Notstrom-Check
        if self.active_article_data["Notstrom"] == "Ja":
            # 3x check if light is turned on
            turned_on = False
            for _ in range(3):
                if not self.light_turned_off():
                    turned_on = True
                    break
            if turned_on is False:
                self.show_error("emergency_light")
            else:
                self.check.progressBar.setProperty("value", 75)
                QApplication.processEvents()
                self.emergency_light = "o.k."
        else:
            # 3x check if light is turned off
            turned_off = False
            for _ in range(3):
                if self.light_turned_off():
                    turned_off = True
                    break
            if turned_off is False:
                self.show_error("voltage_deactivation")
            else:
                self.check.progressBar.setProperty("value", 75)
                QApplication.processEvents()

                self.emergency_light = "o.k."

    def dali_check(self):
        gpio.dali_off()
        time.sleep(1)
        # 3x check if light is turned off
        turned_off = False
        for _ in range(3):
            if self.light_turned_off():
                turned_off = True
                break
        if turned_off is False:
            self.show_error("dali_turn_off")
        else:
            self.check.progressBar.setProperty("value", 75)
            QApplication.processEvents()

        time.sleep(1)

        gpio.dali_on()
        time.sleep(1)
        # 3x check if light is turned on
        turned_on = False
        for _ in range(3):
            if not self.light_turned_off():
                turned_on = True
                break
        if turned_on is False:
            self.show_error("dali_turn_on")
        else:
            self.check.progressBar.setProperty("value", 75)
            QApplication.processEvents()

        time.sleep(1)

        gpio.dali_off()
        time.sleep(1)
        # 3x check if light is turned off
        turned_off = False
        for _ in range(3):
            if self.light_turned_off():
                turned_off = True
                break
        if turned_off is False:
            self.show_error("dali_turn_off")
        else:
            self.check.progressBar.setProperty("value", 75)
            QApplication.processEvents()

            self.dali = "o.k."

    def external_switch_check(self):  # TODO: check if algorithm is correct
        gpio.external_switch_on()
        time.sleep(1)
        # 3x check if light is turned on
        turned_on = False
        for _ in range(3):
            if not self.light_turned_off():
                turned_on = True
                break
        if turned_on is False:
            self.show_error("external_switch_turn_on")
        else:
            self.check.progressBar.setProperty("value", 75)
            QApplication.processEvents()

        time.sleep(1)

        gpio.external_switch_off()
        time.sleep(1)
        # 3x check if light is turned off
        turned_off = False
        for _ in range(3):
            if self.light_turned_off():
                turned_off = True
                break
        if turned_off is False:
            self.show_error("external_switch_turn_off")
        else:
            self.check.progressBar.setProperty("value", 75)
            QApplication.processEvents()

            self.external_switch = "o.k."

    def check_with_ms(self):
        self.check_result = "Not o.k."
        self.motion_sensor = "Not o.k."
        if self.active_article_data["Notstrom"] == "Ja":
            self.emergency_light = "Not o.k."
        else:
            self.emergency_light = "No emergency light built in."
        if self.active_article_data["DALI"] == "Ja":
            self.dali = "Not o.k."
        else:
            self.dali = "No DALI built in."
        if self.active_article_data["Geschalten extern"] == "Ja":
            self.external_switch = "Not o.k."
        else:
            self.external_switch = "No external switch built in."
        self.ms_check()
        self.motion_sensor = "o.k."
        time.sleep(1)
        self.emergency_light_check()
        time.sleep(1)
        self.dali_check()
        time.sleep(1)
        self.external_switch_check()

        self.check.progressBar.setProperty("value", 80)
        QApplication.processEvents()
        self.check_result = "o.k."
        self.confirm_test()

    def check_without_ms(self):
        self.check_result = "Not o.k."
        self.motion_sensor = "No motion sensor built in."
        if self.active_article_data["Notstrom"] == "Ja":
            self.emergency_light = "Not o.k."
        else:
            self.emergency_light = "No emergency light built in."
        if self.active_article_data["DALI"] == "Ja":
            self.dali = "Not o.k."
        else:
            self.dali = "No DALI built in."
        if self.active_article_data["Geschalten extern"] == "Ja":
            self.external_switch = "Not o.k."
        else:
            self.external_switch = "No external switch built in."
        self.normal_check()
        time.sleep(1)
        self.emergency_light_check()
        time.sleep(1)
        self.dali_check()
        time.sleep(1)
        self.external_switch_check()

        self.check.progressBar.setProperty("value", 75)
        self.check_result = "o.k."
        self.confirm_test()

    def start_check(self):
        gpio.green_light_on()
        gpio.deactivate_daylight()
        self.close_cover.pushButton_confirm.setChecked(False)
        # check if "Bewegungsmelder" at article number is "Ja"
        try:
            if self.active_article_data["Bewegungsmelder"] == "Ja":
                self.check.label_text1.setText("Bewegungsmelder-Prüfung...")
                self.check.progressBar.setProperty("value", 10)
                self.check_with_ms()
            elif self.active_article_data["Bewegungsmelder"] == "Nein":
                self.check.label_text1.setText("Licht-Prüfung...")
                self.check.progressBar.setProperty("value", 10)
                self.check_without_ms()
            else:
                print(
                    f"Fehler bei der Bewegungsmelder-Konfiguration der Lampe {self.active_article_data['Name']}"
                )
        except StopIteration:
            return

    def save_protocol(self):
        self.protocol.save_test_data(
            self.current_user,
            self.business_order,
            self.active_article_number,
            self.test_counter,
            self.test_quantity,
            self.motion_sensor,
            self.emergency_light,
            self.dali,
            self.external_switch,
            self.check_result,
        )

    def confirm_test(self):
        self.save_protocol()
        print_label(
            self.business_order,
            self.active_article_number,
            self.test_counter,
            self.test_quantity,
            self.current_user,
        )
        del (
            self.motion_sensor,
            self.check_result,
            self.emergency_light,
            self.dali,
            self.external_switch,
        )
        if self.test_counter < int(self.test_quantity):
            self.test_counter += 1
            self.check.label_text2.setText(f"Prüfung {self.test_counter} von {self.test_quantity}")
        self.start_open_cover()

    def show_error(self, error_code):
        error_messages = {
            "port_not_found": "Port nicht\ngefunden!",
            "capture": "Keine Verbindung\nzum LED-Analyser!",
            "safety_circuit": "Fehler\nSicherheitskreis!",
            "light_measurement": "Fehler bei\nder Lichtmessung!",
            "early_activation": "Licht vor\nBewegung aktiviert!",
            "late_activation": "Licht nach Bewegung\nnicht aktiviert!",
            "no_activation": "Licht nach Stromzufuhr\nnicht aktiviert!",
            "early_deactivation": "Licht zu früh\ndeaktiviert!",
            "late_deactivation": "Licht zu spät\ndeaktiviert!",
            "daylight_deactivation": "Licht durch\nTageslicht nicht deaktiviert!",
            "after_daylight_activation": "Licht nach\nTageslicht nicht aktiviert!",
            "voltage_deactivation": "Licht nach Entfernen\nder Spannung nicht deaktiviert!",
            "emergency_light": "Notlicht\nnicht aktiviert!",
            "dali_turn_on": "Licht nach DALI-\nSignal nicht aktiviert!",
            "dali_turn_off": "Licht nach DALI-\nSignal nicht deaktiviert!",
            "external_switch_turn_on": "Licht durch externen\nSchalter nicht aktiviert!",
            "external_switch_turn_off": "Licht durch externen\nSchalter nicht deaktiviert!",
        }

        gpio.red_light_on()
        gpio.deactivate_voltage()
        self.save_protocol()
        error_message = error_messages.get(error_code, "Ungültiger\nFehlercode!")
        self.error.label_text2.setText(error_message)
        self.main_window.setCurrentWidget(self.error)
        QApplication.processEvents()
        raise StopIteration

    # function for logout buttons
    def logout(self):
        self.user_login.label_text2.hide()
        self.business_order_selection.label_text2.hide()
        self.article_selection.label_text2.hide()
        self.quantity_selection.label_text2.hide()
        self.quantity_selection.lineEdit2_userInput.clear()
        self.quantity_selection.lineEdit2_userInput.setReadOnly(False)
        self.main_window.setCurrentWidget(self.user_login)
        self.user_login.lineEdit_userInput.setFocus()

    # function for app exit
    def exit_app(self):
        self.close_to_exit = True
        self.start_close_cover()


if __name__ == "__main__":
    tester = LightTester()
    tester.start()
