import json
import sys
import time

from calculations.calc_user_login import set_max_font_size_label_filepath
import gpio
from label_print.label import print_label
from light_test.light_capture import light_capture
from log.protocol import Protocol
from PyQt5.QtCore import QCoreApplication, QSettings
from PyQt5.QtGui import QFont
from PyQt5.QtWidgets import QApplication
from settings import LIGHT_SETTINGS_CONFIG_PATH, PI
from ui.article_selection import UiArticleSelection
from ui.business_order_selection import UiBusinessOrderSelection
from ui.close_cover import UiCloseCover
from ui.error import UiError
from ui.main_window import UiMainWindow
from ui.open_cover import UiOpenCover
from ui.pruefung import UiPruefung
from ui.quantity_selection import UiQuantitySelection
from ui.tool_change import UiToolChange
from ui.user_login import UiUserLogin

settings = QSettings("Bilton", "Lampentest")

class LightTester:
    
    def __init__(self) -> None:
        with open(LIGHT_SETTINGS_CONFIG_PATH) as lightSettingsFile:  # noqa: PTH123
            self.light_settings = json.load(lightSettingsFile)
        self.active_article_number = ""
        self.active_article_data = {}
        self.current_user = ""
        self.test_counter = 1
        self.test_quantity = 0
        self.business_order = ""

        self.close_to_exit = False
        self.loop_flag = True

        self.protocol = Protocol()
        

    def start(self):

        gpio.init()

        self.app = QApplication(sys.argv)  # create app

        # create main window
        self.main_window = UiMainWindow()
        # create page open_cover
        self.open_cover = UiOpenCover()
        self.main_window.addWidget(self.open_cover)
        # create page user_login
        self.user_login = UiUserLogin()
        self.main_window.addWidget(self.user_login)
        # create page business_order_selection
        self.business_order_selection = UiBusinessOrderSelection()
        self.main_window.addWidget(self.business_order_selection)
        # create page article_selection
        self.article_selection = UiArticleSelection()
        self.main_window.addWidget(self.article_selection)
        # create page tool_change
        self.tool_change = UiToolChange()
        self.main_window.addWidget(self.tool_change)
        # create page quantity_selection
        self.quantity_selection = UiQuantitySelection()
        self.main_window.addWidget(self.quantity_selection)
        # create page close_cover
        self.close_cover = UiCloseCover()
        self.main_window.addWidget(self.close_cover)
        # create page pruefung
        self.pruefung = UiPruefung()
        self.main_window.addWidget(self.pruefung)
        # create page error
        self.error = UiError()
        self.main_window.addWidget(self.error)

        # button signals
        self.open_cover.pushButton_cancel.clicked.connect(self.cancel_open_cover)
        self.user_login.pushButton_confirm.clicked.connect(self.confirm_user_login)
        self.user_login.pushButton_exit.clicked.connect(self.exit_app)
        self.business_order_selection.pushButton_confirm.clicked.connect(self.confirm_business_order_selection)
        self.business_order_selection.pushButton_logout.clicked.connect(self.logout)
        self.article_selection.pushButton_confirm.clicked.connect(self.confirm_article_selection)
        self.article_selection.pushButton_logout.clicked.connect(self.logout)
        self.tool_change.pushButton_confirm.clicked.connect(self.confirm_tool_change)
        self.quantity_selection.pushButton_logout.clicked.connect(self.logout)
        self.quantity_selection.pushButton_confirm.clicked.connect(self.confirm_quantity_selection)
        self.close_cover.pushButton_confirm.toggled.connect(self.start_close_cover)
        self.pruefung.pushButton_confirm.clicked.connect(self.confirm_test)
        self.error.pushButton_retry.clicked.connect(self.retry_test)
        self.error.pushButton_openCover.clicked.connect(self.open_cover_after_error)

        # load settings
        value = settings.value("filepath")
        if value is not None:
            self.user_login.label_filepath.setText(str(value))
            font = QFont()
            font.setPointSize(set_max_font_size_label_filepath(self.user_login.label_filepath))
            self.user_login.label_filepath.setFont(font)
        else:
            self.user_login.choose_filepath()

        # show main window
        if PI:
            self.main_window.showFullScreen()
        else:
            self.main_window.show()

        self.start_open_cover()
        
        # execute app
        self.app.exec()

    
    def light_turned_off(self):
        #if first value of tuple light_caputre is < 1000 return true
        #get self.intensity from file at article number
        threshold_intensity = 0.1*(int(self.active_article_data["Lichtstrom"]))
        light_capture_result = light_capture()
        if light_capture_result == (-1, -1):
            self.show_error("port_not_found")
        return light_capture_result[0] < threshold_intensity 
        

    def capture_light_values(self):
        light_capture_result = light_capture()
        if light_capture_result == (-1, -1):
            self.show_error("port_not_found")
        target_intensity = int(self.active_article_data["Lichtstrom"])
        target_temperature = int(self.active_article_data["Lichttemperatur"])
        supposed_intensity_min = int(target_intensity-0.1*target_intensity)
        supposed_intensity_max = int(target_intensity+0.1*target_intensity)
        supposed_temperature_min = int(target_temperature-0.1*target_temperature)
        supposed_temperature_max = int(target_temperature+0.1*target_temperature)
        if light_capture_result is not None and supposed_intensity_min < light_capture_result[0] < supposed_intensity_max and supposed_temperature_min < light_capture_result[1] < supposed_temperature_max: 
            self.intensity = light_capture_result[0] 
            self.temperature = light_capture_result[1] 
        else:
            self.intensity = 0
            self.temperature = 0
        return self.intensity, self.temperature


    def activate_emergency_voltage(self):
        if self.active_article_data["DC"] == "Ja" and self.active_article_data["Notstrom"] == "Ja":
            gpio.activate_emergency_voltage_dc()
        elif self.active_article_data["DC"] == "Nein" and self.active_article_data["Notstrom"] == "Ja":
            gpio.activate_emergency_voltage_ac()
        elif self.active_article_data["Notstrom"] == "Nein":
            gpio.deactivate_voltage()
            return
        else:
            print(f"Fehler bei der Notstrom-Konfiguration der Lampe {self.active_article_data['Name']}")
            gpio.deactivate_voltage()

    def retry_test(self):
        self.main_window.setCurrentWidget(self.pruefung)
        QApplication.processEvents()
        self.start_check()

    def open_cover_after_error(self):
        self.test_counter = -1
        self.start_open_cover()
    
    # function for open cover
    def start_open_cover(self):
        self.main_window.setCurrentWidget(self.open_cover)
        QApplication.processEvents()
        gpio.open_lock()
        gpio.yellow_light_on()
        pause_end = time.time()
        opening_time = 25 if PI else 5
        time_stored = 0
        time_passed = 0
        while time_passed <= opening_time and self.loop_flag is True:
            time_passed = time.time() + time_stored - pause_end
            gpio.open_cover()
            if self.open_cover.pushButton_interrupt.isChecked():
                time_stored = time_passed
                while self.open_cover.pushButton_interrupt.isChecked() and self.loop_flag is True:
                    gpio.cover_stop()
                    QCoreApplication.processEvents()
                pause_end = time.time()

            QCoreApplication.processEvents()

        self.open_cover.pushButton_interrupt.setChecked(False)
        self.loop_flag = True
        
        gpio.cover_stop()

        if self.test_counter == 1:
            self.main_window.setCurrentWidget(self.user_login)
            self.user_login.lineEdit_userInput.setFocus()
        elif self.test_counter > self.test_quantity or self.test_counter == -1:
            self.main_window.setCurrentWidget(self.business_order_selection)
        else:
            self.main_window.setCurrentWidget(self.close_cover)

    # function for cancel button on page open_cover
    def cancel_open_cover(self):
        self.loop_flag = False

    # function for confirm button on page user_login
    def confirm_user_login(self):
        user_id = self.user_login.lineEdit_userInput.text()
        user_id = user_id.upper()
        self.user_login.lineEdit_userInput.clear()
        if not user_id.isalpha() or len(user_id) != 4:
            self.user_login.label_text2.show()
            self.user_login.lineEdit_userInput.setFocus()
            return
        self.user_login.label_text2.hide()
        self.current_user = user_id

        self.main_window.setCurrentWidget(self.business_order_selection)
        self.business_order_selection.lineEdit_userInput.setFocus()

    def confirm_business_order_selection(self):
        business_order = self.business_order_selection.lineEdit_userInput.text()
        self.business_order_selection.lineEdit_userInput.clear()
        # check if business order is 10 digit integer
        if not business_order.isnumeric() or len(business_order) != 10:
            self.business_order_selection.label_text2.show()
            self.business_order_selection.lineEdit_userInput.setFocus()
            return
        self.business_order_selection.label_text2.hide()

        self.business_order = business_order
        self.main_window.setCurrentWidget(self.article_selection)
        self.article_selection.lineEdit_userInput.setFocus()

    def confirm_article_selection(self):
        # article number should contain 9 characters (8 numbers and _ on index 6)
        article_number = self.article_selection.lineEdit_userInput.text()
        self.article_selection.lineEdit_userInput.clear()
        if len(article_number) != 9 or article_number[6] != "_" or not article_number[:6].isnumeric() or not article_number[7:].isnumeric():
            self.article_selection.label_text2.show()
            self.article_selection.lineEdit_userInput.setFocus()
            return
        self.article_selection.label_text2.hide()

        self.active_article_number = article_number

        if article_number not in self.light_settings:
            self.article_selection.label_text2.show()
            self.article_selection.lineEdit_userInput.setFocus()
            return
        self.article_selection.label_text2.hide()
        new_tool = self.light_settings[article_number]["Tool"]
        self.active_article_data = self.light_settings[article_number]

        # if tool is not equal to current tool show popup
        old_tool = settings.value("current_tool")
        if old_tool != new_tool:
            self.tool_change.label_text2.setText(f"von {old_tool} zu {new_tool}")
            self.main_window.setCurrentWidget(self.tool_change)

        else:
            self.main_window.setCurrentWidget(self.quantity_selection)
            self.quantity_selection.lineEdit_userInput.setFocus()

    
    def confirm_tool_change(self):
        # save new tool in settings and save tool change in protocol
        new_tool = self.tool_change.label_text2.text().split(" ")[-1]
        self.protocol.save_tool_change(self.current_user, settings.value("current_tool"), new_tool)
        self.main_window.setCurrentWidget(self.quantity_selection)
        self.quantity_selection.lineEdit_userInput.setFocus()

    def confirm_quantity_selection(self):
        # quantity should be an integer between 1 and 9999
        quantity = self.quantity_selection.lineEdit_userInput.text()
        self.quantity_selection.lineEdit_userInput.clear()
        if not quantity.isnumeric() or int(quantity) < 1 or int(quantity) > 9999:
            self.quantity_selection.label_text2.show()
            self.quantity_selection.lineEdit_userInput.setFocus()
            return
        
        self.test_quantity = int(quantity)
        
        self.quantity_selection.label_text2.hide()        
        self.main_window.setCurrentWidget(self.close_cover)
    
    def start_close_cover(self):
        try:
            if self.close_cover.pushButton_confirm.isChecked():
                gpio.close_lock()   # Zuhaltung schließen

                while gpio.unsafe_lock and self.close_cover.pushButton_confirm.isChecked():

                    gpio.close_cover()

                    QCoreApplication.processEvents()  # Allow GUI to process events

                if self.close_cover.pushButton_confirm.isChecked():  # Check the button state again
                    time.sleep(1)
                    if gpio.unsafe_safety_relay:
                        self.show_error("safety_circuit")

                self.close_cover.pushButton_confirm.setChecked(False)
                gpio.cover_stop()  

                if gpio.safety_check:
                    gpio.green_light_on()
                    gpio.deactivate_daylight()
                    
                    self.pruefung.label_text2.setText(f"Prüfung {self.test_counter} von {self.test_quantity}")
                    
                    if self.close_to_exit is True:
                        self.app.quit()

                    else:
                        self.main_window.setCurrentWidget(self.pruefung)
                        self.start_check()

                    QCoreApplication.processEvents()
        except StopIteration:
            return
        
    def check_motion_sensor(self):
        try:
            self.motion_sensor = "Not o.k."
            gpio.activate_main_voltage()
            time.sleep(1)
            
            # 3x check if light is turned off
            turned_off = False
            for _ in range(3):
                if self.light_turned_off():
                    turned_off = True
                    break
            if turned_off is False:
                self.show_error("early_activation")
            else:
                self.pruefung.progressBar.setProperty("value", 15)
                QApplication.processEvents()
            
            #turn motion sensor servo and check if light is turned on 3x
            gpio.turn_motion_sensor_servo()
            turned_on = False
            for _ in range(3):
                if not self.light_turned_off():
                    turned_on = True
                    break
            if turned_on is False:
                self.show_error("late_activation")
            else:
                self.pruefung.progressBar.setProperty("value", 20)
                QApplication.processEvents()

            #caputre light values 3x   
            for _ in range(3):
                self.intensity, self.temperature = self.capture_light_values()
                if self.intensity > 0 and self.temperature > 0:
                    break
            if self.intensity == 0 or self.temperature == 0:
                self.show_error("light_measurement")
            else:
                self.pruefung.progressBar.setProperty("value", 30)
                QApplication.processEvents()

            #wait for light to turn off and count passed time 3x
            early_deactivation = False
            late_deactivation = False
            for _ in range(3):
                start_time = time.time()
                ausschaltzeit = int(self.active_article_data["Ausschaltzeit_Bewegungsmelder"])
                while not self.light_turned_off():
                    pass
                self.time_passed = time.time() - start_time
                if ausschaltzeit-2 > self.time_passed:
                    early_deactivation = True
                elif ausschaltzeit+2 < self.time_passed:
                    late_deactivation = True
                else:
                    break
            if early_deactivation is True:
                self.show_error("early_deactivation")
            elif late_deactivation is True:
                self.show_error("late_deactivation")
            else:
                self.pruefung.progressBar.setProperty("value", 50)
                QApplication.processEvents()

            time.sleep(1)

            #daylight sensor check
            #turn motion sensor servo and check if light is turned on 3x
            gpio.turn_motion_sensor_servo()
            turned_on = False
            for _ in range(3):
                if not self.light_turned_off():
                    turned_on = True
                    break
            if turned_on is False:
                self.show_error("late_activation")
            else:
                self.pruefung.progressBar.setProperty("value", 60)
                QApplication.processEvents()

            gpio.activate_daylight()
            time.sleep(10)
            gpio.deactivate_daylight()

            # 3x check if light is turned off
            turned_off = False
            for _ in range(3):
                if self.light_turned_off():
                    turned_off = True
                    break
            if turned_off is False:
                self.show_error("daylight_deactivation")
            else:
                self.pruefung.progressBar.setProperty("value", 70)
                QApplication.processEvents()
            
            time.sleep(1)
            
            #turn motion sensor servo and check if light is turned on 3x
            gpio.turn_motion_sensor_servo()
            turned_on = False
            for _ in range(3):
                if not self.light_turned_off():
                    turned_on = True
                    break
            if turned_on is False:
                self.show_error("late_activation")

            time.sleep(1)

            #deactivate voltage and check if light is turned off
            gpio.deactivate_voltage()
            time.sleep(1)
            if not self.light_turned_off():
                self.show_error("voltage_deactivation")

            self.motion_sensor = "o.k."
            print("Bewegungsmelder-Prüfung erfolgreich")
            self.pruefung.progressBar.setProperty("value", 75)
            QApplication.processEvents()

        except StopIteration:
            return

    def check_light(self):
        self.motion_sensor = "No motion sensor built in."
        gpio.activate_main_voltage()
        time.sleep(1)
        if self.light_turned_off():
            print("Licht nicht aktiviert")
            gpio.deactivate_voltage()
            return
        for _ in range(3):
            self.intensity, self.temperature = self.capture_light_values()
            if self.intensity > 0 and self.temperature > 0:
                break
        if self.intensity == 0 or self.temperature == 0:
            print("Fehler bei der Lichtmessung")
            gpio.deactivate_voltage()
            return
        gpio.deactivate_voltage()
        time.sleep(1)
        if not self.light_turned_off():
            print("Licht nach Entfernen der Spannung nicht deaktiviert!")
            return
        print("Licht-Prüfung erfolgreich")
        
    def start_check(self):
        # check if "Bewegungsmelder" at article number is "Ja"
        if self.active_article_data["Bewegungsmelder"] == "Ja":
            self.pruefung.label_text1.setText("Bewegungsmelder-Prüfung...")
            self.pruefung.progressBar.setProperty("value", 10)
            self.check_motion_sensor()
        elif self.active_article_data["Bewegungsmelder"] == "Nein":
            self.pruefung.label_text1.setText("Licht-Prüfung...")
            self.pruefung.progressBar.setProperty("value", 10)
            self.check_light()
        else:
            print(f"Fehler bei der Bewegungsmelder-Konfiguration der Lampe {self.active_article_data['Name']}")
                
    def confirm_test(self):
        self.protocol.save_test_data(self.current_user, self.business_order, self.active_article_number, self.test_counter, self.test_quantity, self.intensity, self.temperature, self.motion_sensor)
        print_label(self.business_order, self.active_article_number, self.test_counter, self.test_quantity, self.current_user)
        del self.intensity, self.temperature, self.motion_sensor
        if self.test_counter <= int(self.test_quantity):
            self.test_counter += 1
            self.pruefung.label_text2.setText(f"Prüfung {self.test_counter} von {self.test_quantity}")
            self.start_open_cover()
            self.start_close_cover()

    def show_error(self, error_code):
        error_messages = {
            "port_not_found": "Port nicht\ngefunden!",
            "safety_circuit": "Fehler\nSicherheitskreis!",
            "light_measurement": "Fehler bei\nder Lichtmessung!",
            "early_activation": "Licht vor\nBewegung aktiviert!",
            "late_activation": "Licht nach Bewegung\nnicht aktiviert!",
            "early_deactivation": "Licht zu früh\ndeaktiviert!",
            "late_deactivation": "Licht zu spät\ndeaktiviert!",
            "daylight_deactivation": "Licht durch\nTageslicht nicht deaktiviert!",
            "voltage_deactivation": "Licht nach Entfernen\nder Spannung nicht deaktiviert!",
            }

        gpio.red_light_on()
        gpio.deactivate_voltage()
        error_message = error_messages.get(error_code, "Ungültiger\nFehlercode!")
        self.error.label_text2.setText(error_message)
        self.main_window.setCurrentWidget(self.error)
        QApplication.processEvents()
        raise StopIteration


    # function for logout buttons
    def logout(self):
        self.main_window.setCurrentWidget(self.user_login)
        self.user_login.lineEdit_userInput.setFocus()

    # function for app exit
    def exit_app(self):
        self.close_to_exit = True
        gpio.cleanup()
        self.main_window.setCurrentWidget(self.close_cover)
        
    
if __name__ == "__main__":
    tester = LightTester()
    tester.start()
