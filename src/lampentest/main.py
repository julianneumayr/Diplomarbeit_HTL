import csv
import json
import sys
import time

from calculations.calc_input_widgets import set_max_font_size_label_filepath
import dali
import gpio
from label_print.label import print_label
from light_test.light_capture import light_capture
from log.protocol import Protocol
from PyQt5.QtCore import QCoreApplication, QSettings, QTimer
from PyQt5.QtGui import QFont
from PyQt5.QtWidgets import QApplication
from settings import (
    COVER_OPENING_TIME,
    LIGHT_SETTINGS_CONFIG_PATH,
    PI,
    THRESHOLD_DALI_BRIGHTNESS,
    THRESHOLD_DAYLIGHT_BRIGHTNESS,
)
from ui.article_selection import UiArticleSelection
from ui.business_order_selection import UiBusinessOrderSelection
from ui.check import UiCheck
from ui.close_cover import UiCloseCover
from ui.error import UiError
from ui.exit import UiExit
from ui.main_window import UiMainWindow
from ui.quantity_selection import UiQuantitySelection
from ui.tool_change import UiToolChange
from ui.user_login import UiUserLogin

settings = QSettings("Bilton", "Lampentest")


class LightTester:
    def __init__(self) -> None:
        with open(LIGHT_SETTINGS_CONFIG_PATH) as lightSettingsFile:  # noqa: PTH123
            self.light_settings = json.load(lightSettingsFile)
        self.active_article_number = ""
        self.active_article_data = {}
        self.current_user = ""
        self.test_counter = 0
        self.test_quantity = 0
        self.business_order = ""

        self.time_stored = 0
        self.close_to_exit = False

        self.time_passed = 0

        self.protocol = Protocol()

    def start(self):
        gpio.init()

        self.app = QApplication(sys.argv)  # create app

        # create main window
        self.main_window = UiMainWindow()
        # create page user_login
        self.user_login = UiUserLogin()
        self.main_window.addWidget(self.user_login)
        # create page business_order_selection
        self.business_order_selection = UiBusinessOrderSelection()
        self.main_window.addWidget(self.business_order_selection)
        # create page article_selection
        self.article_selection = UiArticleSelection()
        self.main_window.addWidget(self.article_selection)
        # create page tool_change
        self.tool_change = UiToolChange()
        self.main_window.addWidget(self.tool_change)
        # create page quantity_selection
        self.quantity_selection = UiQuantitySelection()
        self.main_window.addWidget(self.quantity_selection)
        # create page close_cover
        self.close_cover = UiCloseCover()
        self.main_window.addWidget(self.close_cover)
        # create page check
        self.check = UiCheck()
        self.main_window.addWidget(self.check)
        # create page error
        self.error = UiError()
        self.main_window.addWidget(self.error)
        # create page exit
        self.exit = UiExit()
        self.main_window.addWidget(self.exit)

        # button signals
        self.exit.pushButton_keepOpen.clicked.connect(self.quit_app)
        self.exit.pushButton_closeCover.clicked.connect(self.close_cover_to_exit)
        self.exit.pushButton_back.clicked.connect(self.back_to_login)
        self.user_login.pushButton_confirm.clicked.connect(self.confirm_user_login)
        self.user_login.pushButton_exit.clicked.connect(self.exit_app)
        self.user_login.pushButton_openCover.clicked.connect(self.start_open_cover)
        self.user_login.pushButton_closeCover.clicked.connect(self.start_close_cover)
        self.user_login.pushButton_light.clicked.connect(self.daylight_toggle)
        self.business_order_selection.pushButton_confirm.clicked.connect(
            self.confirm_business_order_selection
        )
        self.business_order_selection.pushButton_logout.clicked.connect(self.logout)
        self.business_order_selection.pushButton_openCover.clicked.connect(self.start_open_cover)
        self.business_order_selection.pushButton_closeCover.clicked.connect(self.start_close_cover)
        self.business_order_selection.pushButton_light.clicked.connect(self.daylight_toggle)
        self.article_selection.pushButton_confirm.clicked.connect(self.confirm_article_selection)
        self.article_selection.pushButton_logout.clicked.connect(self.logout)
        self.article_selection.pushButton_back.clicked.connect(
            lambda: self.main_window.setCurrentWidget(self.business_order_selection)
        )
        self.tool_change.pushButton_confirm.clicked.connect(self.confirm_tool_change)
        self.quantity_selection.pushButton_logout.clicked.connect(self.logout)
        self.quantity_selection.pushButton_back.clicked.connect(
            lambda: self.main_window.setCurrentWidget(self.article_selection)
        )
        self.quantity_selection.pushButton_confirm.clicked.connect(self.confirm_quantity_selection)
        self.close_cover.pushButton_confirm.clicked.connect(self.start_close_cover)
        self.close_cover.pushButton_back.clicked.connect(self.close_cover_back)
        self.close_cover.pushButton_back1.clicked.connect(self.close_cover_back1)
        self.check.pushButton_confirm.clicked.connect(self.complete_check)
        self.error.pushButton_retry.clicked.connect(self.retry_test)
        self.error.pushButton_restart.clicked.connect(self.restart)

        self.error_timer = QTimer()
        self.error_timer.timeout.connect(lambda: self.business_order_selection.label_text2.hide())

        # load settings
        value = settings.value("filepath")
        if value is not None:
            self.user_login.label_filepath.setText(str(value))
            font = QFont()
            font.setPointSize(set_max_font_size_label_filepath(self.user_login.label_filepath))
            self.user_login.label_filepath.setFont(font)
        else:
            self.user_login.choose_filepath()

        # show main window
        if PI:
            self.main_window.showFullScreen()
        else:
            self.main_window.show()

        if settings.contains("time_stored"):
            gpio.activate_daylight()

        gpio.yellow_light_on()
        self.user_login.lineEdit_userInput.setFocus()

        # execute app
        self.app.exec()

    def light_turned_off(self):
        light_capture_result = light_capture()
        if light_capture_result == -1:
            self.show_error("port_not_found")
        elif light_capture_result == -2:
            self.show_error("capture")
        return light_capture_result > THRESHOLD_DALI_BRIGHTNESS

    def light_turned_off_during_daylight(self):
        light_capture_result = light_capture()
        if light_capture_result == -1:
            self.show_error("port_not_found")
        elif light_capture_result == -2:
            self.show_error("capture")
        return light_capture_result > THRESHOLD_DAYLIGHT_BRIGHTNESS

    def daylight_toggle(self):
        if gpio.daylight_on():
            gpio.deactivate_daylight()
        else:
            gpio.activate_daylight()

    def back_to_login(self):
        self.main_window.setCurrentWidget(self.user_login)
        self.user_login.lineEdit_userInput.setFocus()

    def restart(self):
        gpio.set_initial_gpio_state(False)
        gpio.yellow_light_on()
        self.main_window.setCurrentWidget(self.business_order_selection)
        self.business_order_selection.lineEdit_userInput.setFocus()

    def retry_test(self):
        self.main_window.setCurrentWidget(self.check)
        QApplication.processEvents()
        self.start_check()

    def close_cover_to_exit(self):
        self.close_cover.pushButton_back.setVisible(True)
        self.main_window.setCurrentWidget(self.close_cover)
        QApplication.processEvents()
        self.start_close_cover()

    def close_cover_back(self):
        self.close_cover.pushButton_confirm.setChecked(False)
        self.main_window.setCurrentWidget(self.exit)
        self.close_cover.pushButton_back.setVisible(False)

    def close_cover_back1(self):
        self.close_cover.pushButton_confirm.setChecked(False)
        self.main_window.setCurrentWidget(self.quantity_selection)
        self.close_cover.pushButton_back1.setVisible(False)

    def complete_check(self):
        print_label(
            self.business_order,
            self.active_article_number,
            self.test_counter,
            self.test_quantity,
            self.current_user,
        )

        self.check.pushButton_confirm.setVisible(False)
        gpio.set_initial_gpio_state(False)
        gpio.yellow_light_on()
        self.main_window.setCurrentWidget(self.business_order_selection)
        self.business_order_selection.pushButton_openCover.setChecked(True)
        self.start_open_cover()
        QApplication.processEvents()

    # function for open cover
    def start_open_cover(self):
        gpio.open_lock()
        gpio.yellow_light_on()
        gpio.activate_daylight()
        self.user_login.pushButton_closeCover.setChecked(False)
        self.business_order_selection.pushButton_closeCover.setChecked(False)
        start_time = time.time()
        if settings.contains("time_stored"):
            time_stored = float(settings.value("time_stored"))
        else:
            time_stored = 0
        while time.time() - start_time + time_stored <= COVER_OPENING_TIME:
            gpio.open_cover()
            settings.setValue("time_stored", time.time() - start_time + time_stored)

            if (
                not self.user_login.pushButton_openCover.isChecked()
                and not self.business_order_selection.pushButton_openCover.isChecked()
            ):
                self.user_login.pushButton_openCover.setChecked(False)
                self.business_order_selection.pushButton_openCover.setChecked(False)
                break

            QApplication.processEvents()

        if self.main_window.currentWidget() == self.user_login:
            self.user_login.lineEdit_userInput.setFocus()
        elif self.main_window.currentWidget() == self.business_order_selection:
            self.business_order_selection.lineEdit_userInput.setFocus()

        gpio.cover_stop()
        self.user_login.pushButton_openCover.setChecked(False)
        self.business_order_selection.pushButton_openCover.setChecked(False)
        QApplication.processEvents()

    # function for confirm button on page user_login
    def confirm_user_login(self):
        if self.user_login.pushButton_closeCover.isChecked():
            self.business_order_selection.pushButton_closeCover.setChecked(True)
            self.user_login.pushButton_closeCover.setChecked(False)
        if self.user_login.pushButton_openCover.isChecked():
            self.business_order_selection.pushButton_openCover.setChecked(True)
            self.user_login.pushButton_openCover.setChecked(False)
        user_id = self.user_login.lineEdit_userInput.text()
        user_id = user_id.upper()
        self.user_login.lineEdit_userInput.clear()
        if not user_id.isalpha() or len(user_id) != 4:
            self.user_login.label_text2.show()
            self.user_login.lineEdit_userInput.setFocus()
            if self.business_order_selection.pushButton_closeCover.isChecked():
                self.user_login.pushButton_closeCover.setChecked(True)
                self.business_order_selection.pushButton_closeCover.setChecked(False)
            if self.business_order_selection.pushButton_openCover.isChecked():
                self.user_login.pushButton_openCover.setChecked(True)
                self.business_order_selection.pushButton_openCover.setChecked(False)
            return
        self.user_login.label_text2.hide()
        self.current_user = user_id

        self.main_window.setCurrentWidget(self.business_order_selection)
        self.business_order_selection.lineEdit_userInput.setFocus()

    def confirm_business_order_selection(self):
        business_order = self.business_order_selection.lineEdit_userInput.text()
        self.business_order_selection.lineEdit_userInput.clear()
        # check if business order is 10 digit integer
        if not business_order.isnumeric() or len(business_order) != 10:
            self.business_order_selection.label_text2.show()
            self.business_order_selection.lineEdit_userInput.setFocus()
            return
        self.business_order_selection.label_text2.hide()

        self.business_order_selection.pushButton_closeCover.setChecked(False)
        self.business_order_selection.pushButton_openCover.setChecked(False)

        self.business_order = business_order
        self.main_window.setCurrentWidget(self.article_selection)
        self.article_selection.lineEdit_userInput.setFocus()

    def confirm_article_selection(self):
        article_number = self.article_selection.lineEdit_userInput.text()
        self.article_selection.lineEdit_userInput.clear()
        if (
            len(article_number) != 9
            or article_number[6] != "_"
            or not article_number[:6].isnumeric()
            or not article_number[7:].isnumeric()
        ):
            self.article_selection.label_text2.show()
            self.article_selection.lineEdit_userInput.setFocus()
            return
        self.article_selection.label_text2.hide()

        self.active_article_number = article_number

        if article_number not in self.light_settings:
            self.article_selection.label_text2.show()
            self.article_selection.lineEdit_userInput.setFocus()
            return
        self.article_selection.label_text2.hide()
        new_tool = self.light_settings[article_number]["Tool"]
        self.active_article_data = self.light_settings[article_number]

        # open protocol.csv and check this business order-article number-combination is already in protocol
        self.protocol.create_protocol()
        filepath = settings.value("filepath")
        with open(f"{filepath}/protokoll.csv") as protocol_file:  # noqa: PTH123
            # save data from protocol.csv
            csv_reader = csv.reader(protocol_file, delimiter=";")
            self.protocol_data = []
            for row in csv_reader:
                self.protocol_data.append(row)

        self.csv_line = None

        for line in self.protocol_data:
            if line[3] == self.business_order and line[4] == self.active_article_number:
                self.csv_line = line
                # if errorcode is not "kein Fehler"
                if line[-2] != "o.k.":
                    # set self.quantity_selection.lineEdit1_userInput to last number
                    self.quantity_selection.lineEdit1_userInput.setText(line[6])
                    self.quantity_selection.lineEdit1_userInput.setReadOnly(False)
                    # set self.quantity_selection.lineEdit2_userInput to last quantity
                    self.quantity_selection.lineEdit2_userInput.setText(line[7])
                    self.quantity_selection.lineEdit2_userInput.setReadOnly(True)
                # if number of last test is smaller than quantity
                elif int(line[6]) < int(line[7]):
                    # set self.quantity_selection.lineEdit1_userInput to last number + 1
                    self.quantity_selection.lineEdit1_userInput.setText(str(int(line[6]) + 1))
                    self.quantity_selection.lineEdit1_userInput.setReadOnly(False)
                    # set self.quantity_selection.lineEdit2_userInput to last quantity
                    self.quantity_selection.lineEdit2_userInput.setText(line[7])
                    # make self.quantity_selection.lineEdit2_userInput uneditable
                    self.quantity_selection.lineEdit2_userInput.setReadOnly(True)
            else:
                # set self.quantity_selection.lineEdit1_userInput to 1
                self.quantity_selection.lineEdit1_userInput.setText("1")
                self.quantity_selection.lineEdit1_userInput.setReadOnly(False)
                # make self.quantity_selection.lineEdit2_userInput editable
                self.quantity_selection.lineEdit2_userInput.setReadOnly(False)

        # if tool is not equal to current tool show popup
        old_tool = settings.value("current_tool")
        if old_tool != new_tool:
            self.tool_change.label_text2.setText(f"von {old_tool} zu {new_tool}")
            self.main_window.setCurrentWidget(self.tool_change)

        else:
            self.main_window.setCurrentWidget(self.quantity_selection)
            self.quantity_selection.lineEdit1_userInput.setFocus()

    def confirm_tool_change(self):
        # save new tool in settings and save tool change in protocol
        new_tool = self.tool_change.label_text2.text().split(" ")[-1]
        self.protocol.save_tool_change(self.current_user, settings.value("current_tool"), new_tool)
        self.main_window.setCurrentWidget(self.quantity_selection)
        self.quantity_selection.lineEdit1_userInput.setFocus()

    def confirm_quantity_selection(self):
        if (
            self.quantity_selection.active_lineedit == self.quantity_selection.lineEdit1_userInput
            and not self.quantity_selection.lineEdit2_userInput.isReadOnly()
        ):
            self.quantity_selection.lineEdit2_userInput.setFocus()
        else:
            # quantity should be an integer between 1 and 9999
            test_counter = self.quantity_selection.lineEdit1_userInput.text()
            quantity = self.quantity_selection.lineEdit2_userInput.text()
            self.quantity_selection.lineEdit1_userInput.clear()
            self.quantity_selection.lineEdit2_userInput.clear()
            if (
                not (test_counter.isnumeric() and quantity.isnumeric())
                or int(test_counter) < 1
                or int(quantity) < 1
                or int(test_counter) > 9999
                or int(quantity) > 9999
            ):
                self.quantity_selection.label_text2.setText(
                    "Bitte geben Sie eine gültige Stückzahl zwischen 1 und 9999 ein!"
                )
                self.quantity_selection.label_text2.show()
                self.quantity_selection.lineEdit1_userInput.setFocus()
                if self.quantity_selection.lineEdit2_userInput.isReadOnly():
                    self.quantity_selection.lineEdit2_userInput.setText(quantity)
                return
            elif int(test_counter) > int(quantity):
                self.quantity_selection.label_text2.setText(
                    "Die Stückzahl der Lampe kann höchstens der Gesamtanzahl entsprechen!"
                )
                self.quantity_selection.label_text2.show()
                self.quantity_selection.lineEdit1_userInput.setFocus()
                if self.quantity_selection.lineEdit2_userInput.isReadOnly():
                    self.quantity_selection.lineEdit2_userInput.setText(quantity)
                return
            elif (
                self.csv_line is not None
                and self.csv_line[3] == self.business_order
                and self.csv_line[4] == self.active_article_number
                and self.csv_line[6] == test_counter
                and self.csv_line[7] == quantity
                and self.csv_line[-2] == "o.k."
            ):
                self.quantity_selection.label_text2.setText(
                    "Lampe wurde bereits erfolgreich geprüft!"
                )
                self.quantity_selection.label_text2.show()
                self.quantity_selection.lineEdit1_userInput.setFocus()
                if self.quantity_selection.lineEdit2_userInput.isReadOnly():
                    self.quantity_selection.lineEdit2_userInput.setText(quantity)
                return

            self.close_cover.pushButton_back1.setVisible(True)

            self.test_counter = int(test_counter)
            self.test_quantity = int(quantity)

            self.quantity_selection.label_text2.hide()
            self.main_window.setCurrentWidget(self.close_cover)
            QApplication.processEvents()

    def start_close_cover(self):
        self.user_login.pushButton_openCover.setChecked(False)
        self.business_order_selection.pushButton_openCover.setChecked(False)
        start_time = time.time()
        if settings.contains("time_stored"):
            time_stored = float(settings.value("time_stored"))
        else:
            time_stored = 0
        while not gpio.lock_engaged():
            settings.setValue("time_stored", time_stored - time.time() + start_time)
            gpio.close_cover()
            QCoreApplication.processEvents()

            if (
                not self.close_cover.pushButton_confirm.isChecked()
                and not self.user_login.pushButton_closeCover.isChecked()
                and not self.business_order_selection.pushButton_closeCover.isChecked()
            ):
                gpio.cover_stop()
                self.close_cover.pushButton_confirm.setChecked(False)
                self.user_login.pushButton_closeCover.setChecked(False)
                self.business_order_selection.pushButton_closeCover.setChecked(False)
                break

        if self.main_window.currentWidget() == self.user_login:
            self.user_login.lineEdit_userInput.setFocus()
        elif self.main_window.currentWidget() == self.business_order_selection:
            self.business_order_selection.lineEdit_userInput.setFocus()

        if gpio.lock_engaged():
            time.sleep(1)
            gpio.cover_stop()
            settings.remove("time_stored")
            QCoreApplication.processEvents()
            if (
                self.close_cover.pushButton_confirm.isChecked()
                or self.user_login.pushButton_closeCover.isChecked()
                or self.business_order_selection.pushButton_closeCover.isChecked()
            ):
                if self.main_window.currentWidget() == self.close_cover:
                    gpio.close_lock()
                    time.sleep(0.5)
                    if not gpio.safety_check():
                        self.close_cover.pushButton_confirm.setChecked(False)
                        self.business_order_selection.label_text2.setText(
                            "Fehler Sicherheitskreis!"
                        )
                        self.business_order_selection.label_text2.show()
                        self.error_timer.start(10000)
                        self.main_window.setCurrentWidget(self.business_order_selection)
                        self.business_order_selection.pushButton_openCover.setChecked(True)
                        self.start_open_cover()
                        return

                self.close_cover.pushButton_confirm.setChecked(False)
                self.user_login.pushButton_closeCover.setChecked(False)
                self.business_order_selection.pushButton_closeCover.setChecked(False)

                self.close_cover.pushButton_back.setVisible(False)
                self.close_cover.pushButton_back1.setVisible(False)

                if self.close_to_exit is True:
                    self.quit_app()

                elif self.main_window.currentWidget() == self.close_cover:
                    self.check.label_text2.setText(
                        f"Lampe {self.test_counter} von {self.test_quantity}"
                    )
                    self.main_window.setCurrentWidget(self.check)
                    self.start_check()

                    QCoreApplication.processEvents()

    def normal_check(self):
        if PI:
            gpio.activate_main_voltage()
            time.sleep(
                int(self.active_article_data["Wartezeit_Initialisierung"])
            )  # initial wait time

            # 3x check if light is turned on
            turned_on = False
            for _ in range(3):
                if not self.light_turned_off():
                    turned_on = True
                    break
            if turned_on is False:
                self.show_error("no_activation")

    def ms_check(self):
        if PI:
            gpio.activate_main_voltage()

            # Licht vor Bewegung aus?
            for _ in range(3):
                time.sleep(
                    int(self.active_article_data["Wartezeit_Initialisierung"])
                )  # initial wait time

                # 3x check if light is turned off
                turned_off = False
                if self.light_turned_off():
                    turned_off = True
                    break
                else:
                    gpio.deactivate_voltage()
                    time.sleep(1)
                    gpio.activate_main_voltage()

            if not turned_off:
                self.show_error("early_activation")

            self.check.progressBar.setProperty("value", 20)
            QApplication.processEvents()

            time.sleep(1)

            # turn motion sensor servo and check if light is turned on 3x
            for _ in range(3):
                gpio.turn_motion_sensor_servo()
                turned_on = False
                if not self.light_turned_off():
                    turned_on = True
                    break

            if turned_on is False:
                self.show_error("late_activation")

            self.check.progressBar.setProperty("value", 30)
            QApplication.processEvents()

            # wait for light to turn off and count passed time 3x
            for _ in range(3):
                self.check.progressBar.setProperty("value", 40)
                self.check.label_text1.setText("Ausschaltzeit-Prüfung...")
                QApplication.processEvents()
                ausschaltzeit = int(self.active_article_data["Ausschaltzeit_Bewegungsmelder"])
                start_time = time.time()
                while not self.light_turned_off():
                    self.time_passed = time.time() - start_time
                    if self.time_passed > ausschaltzeit + 5:
                        break
                if ausschaltzeit - 2 < self.time_passed < ausschaltzeit + 2:
                    break
                else:
                    gpio.turn_motion_sensor_servo()
            if ausschaltzeit - 2 > self.time_passed:
                self.show_error("early_deactivation")
            elif ausschaltzeit + 2 < self.time_passed:
                self.show_error("late_deactivation")
            else:
                self.check.progressBar.setProperty("value", 50)
                QApplication.processEvents()

            time.sleep(1)

            # daylight sensor check
            # turn motion sensor servo and check if light is turned off 3x
            self.check.progressBar.setProperty("value", 50)
            self.check.label_text1.setText("Tageslicht-Prüfung...")
            QApplication.processEvents()
            gpio.activate_daylight()
            time.sleep(int(self.active_article_data["Tageslicht_Wartezeit"]))

            for _ in range(3):
                gpio.turn_motion_sensor_servo()

                # 3x check if light is turned off
                turned_off = False
                if self.light_turned_off_during_daylight():
                    turned_off = True
                    gpio.deactivate_daylight()
                    break
            if turned_off is False:
                self.show_error("daylight_deactivation")

            self.motion_sensor = "o.k."

            time.sleep(1)

        elif not PI:
            self.motion_sensor = "o.k."

    def dali_check(self):
        self.check.progressBar.setProperty("value", 60)
        if PI and self.active_article_data["DALI"] == "Ja":
            self.check.label_text1.setText("DALI-Prüfung...")
            QApplication.processEvents()

            gpio.dali_psu_on()
            time.sleep(1)

            gpio.turn_motion_sensor_servo()
            time.sleep(1)
            # 3x check if light is turned on
            turned_on = False
            for _ in range(3):
                if not self.light_turned_off():
                    turned_on = True
                    break
            if turned_on is False:
                self.show_error("dali_turn_on")

            if dali.turn_off() == -1:
                self.show_error("dali_not_connected")
            time.sleep(1)
            # 3x check if light is turned off
            turned_off = False
            for _ in range(3):
                if self.light_turned_off():
                    turned_off = True
                    break
            if turned_off is False:
                self.show_error("dali_turn_off")
            else:
                self.check.progressBar.setProperty("value", 65)
                QApplication.processEvents()

            time.sleep(1)

            gpio.dali_psu_off()
            self.dali = "o.k."

        elif not PI and self.active_article_data["DALI"] == "Ja":
            self.dali = "o.k."

    def external_switch_check(self):
        self.check.progressBar.setProperty("value", 70)
        if PI and self.active_article_data["Geschalten extern"] == "Ja":
            self.check.label_text1.setText("Externer Kontakt-Prüfung...")
            QApplication.processEvents()
            # 3x check if light is turned off
            turned_off = False
            for _ in range(3):
                if self.light_turned_off():
                    turned_off = True
                    break
            if turned_off is False:
                self.show_error("external_switch_off")

            gpio.external_switch_on()
            time.sleep(1)
            gpio.external_switch_off()
            # 3x check if light is turned on
            turned_on = False
            for _ in range(3):
                if not self.light_turned_off():
                    turned_on = True
                    break
            if turned_on is False:
                self.show_error("external_switch_turn_on")

        elif not PI and self.active_article_data["Geschalten extern"] == "Ja":
            self.external_switch = "o.k."

    def emergency_light_check(self):
        # Notstrom-Check
        self.check.progressBar.setProperty("value", 80)
        if PI:
            if self.active_article_data["Notstrom"] == "Ja":
                self.check.label_text1.setText("Notstrom-Prüfung...")
                QApplication.processEvents()

                if self.active_article_data["DC"] == "Ja":
                    gpio.activate_emergency_voltage_dc()
                else:
                    gpio.activate_emergency_voltage_ac()
                time.sleep(1)

                # 3x check if light is turned on
                turned_on = False
                for _ in range(3):
                    if not self.light_turned_off():
                        turned_on = True
                        break
                if turned_on is False:
                    self.show_error("emergency_light")
                else:
                    self.check.progressBar.setProperty("value", 90)
                    QApplication.processEvents()
                    self.emergency_light = "o.k."
            else:
                self.check.label_text1.setText("Abschaltung...")
                QApplication.processEvents()

                # 3x check if light is turned off
                gpio.deactivate_voltage()
                time.sleep(1)

                turned_off = False
                for _ in range(3):
                    if self.light_turned_off():
                        turned_off = True
                        break
                if turned_off is False:
                    self.show_error("voltage_deactivation")
                else:
                    self.check.progressBar.setProperty("value", 90)
                    QApplication.processEvents()

                    self.emergency_light = "o.k."
        else:
            self.emergency_light = "o.k."

    def check_with_ms(self):
        self.check_result = "Not o.k."
        self.motion_sensor = "Not o.k."
        if self.active_article_data["Notstrom"] == "Ja":
            self.emergency_light = "Not o.k."
        else:
            self.emergency_light = "No emergency light built in."
        if self.active_article_data["DALI"] == "Ja":
            self.dali = "Not o.k."
        else:
            self.dali = "No DALI built in."
        if self.active_article_data["Geschalten extern"] == "Ja":
            self.external_switch = "Not o.k."
        else:
            self.external_switch = "No external switch built in."
        self.ms_check()
        time.sleep(1)
        self.dali_check()
        time.sleep(1)
        self.external_switch_check()
        time.sleep(1)
        self.emergency_light_check()

        self.check.label_text1.setText("Prüfung abgeschlossen!")
        self.check.progressBar.setProperty("value", 100)
        self.check_result = "o.k."
        self.save_check_protocol()
        self.check.pushButton_confirm.setVisible(True)

    def check_without_ms(self):
        self.check_result = "Not o.k."
        self.motion_sensor = "No motion sensor built in."
        if self.active_article_data["Notstrom"] == "Ja":
            self.emergency_light = "Not o.k."
        else:
            self.emergency_light = "No emergency light built in."
        if self.active_article_data["DALI"] == "Ja":
            self.dali = "Not o.k."
        else:
            self.dali = "No DALI built in."
        if self.active_article_data["Geschalten extern"] == "Ja":
            self.external_switch = "Not o.k."
        else:
            self.external_switch = "No external switch built in."
        self.normal_check()
        time.sleep(1)
        self.dali_check()
        time.sleep(1)
        self.external_switch_check()
        time.sleep(1)
        self.emergency_light_check()

        self.check.label_text1.setText("Prüfung abgeschlossen!")
        self.check.progressBar.setProperty("value", 100)
        self.check_result = "o.k."
        self.save_check_protocol()
        self.check.pushButton_confirm.setVisible(True)

    def start_check(self):
        gpio.set_initial_gpio_state(False)
        gpio.green_light_on()
        gpio.deactivate_daylight()
        self.close_cover.pushButton_confirm.setChecked(False)
        # check if "Bewegungsmelder" at article number is "Ja"
        try:
            if self.active_article_data["Bewegungsmelder"] == "Ja":
                self.check.label_text1.setText("Bewegungsmelder-Prüfung...")
                self.check.progressBar.setProperty("value", 10)
                self.check_with_ms()
            elif self.active_article_data["Bewegungsmelder"] == "Nein":
                self.check.label_text1.setText("Licht-Prüfung...")
                self.check.progressBar.setProperty("value", 10)
                self.check_without_ms()
        except Exception:
            return

    def save_error_protocol(self, error_message):
        self.protocol.save_test_data(
            self.current_user,
            self.business_order,
            self.active_article_number,
            self.test_counter,
            self.test_quantity,
            self.motion_sensor,
            self.emergency_light,
            self.dali,
            self.external_switch,
            self.check_result,
            error_message,
        )

    def save_check_protocol(self):
        self.protocol.save_test_data(
            self.current_user,
            self.business_order,
            self.active_article_number,
            self.test_counter,
            self.test_quantity,
            self.motion_sensor,
            self.emergency_light,
            self.dali,
            self.external_switch,
            self.check_result,
            "kein Fehler",
        )

    def show_error(self, error_code):
        error_messages = {
            "port_not_found": "Port nicht\ngefunden!",
            "capture": "Keine Verbindung\nzum LED-Analyser!",
            "safety_circuit": "Fehler\nSicherheitskreis!",
            "light_measurement": "Fehler bei\nder Lichtmessung!",
            "early_activation": "Licht vor\nBewegung aktiviert!",
            "late_activation": "Licht nach Bewegung\nnicht aktiviert!",
            "no_activation": "Licht nach Stromzufuhr\nnicht aktiviert!",
            "early_deactivation": "Licht zu früh\ndeaktiviert!",
            "late_deactivation": "Licht zu spät\ndeaktiviert!",
            "daylight_deactivation": "Licht durch\nTageslicht nicht deaktiviert!",
            "after_daylight_activation": "Licht nach\nTageslicht nicht aktiviert!",
            "voltage_deactivation": "Licht nach Entfernen\nder Spannung nicht deaktiviert!",
            "emergency_light": "Notlicht\nnicht aktiviert!",
            "dali_not_connected": "Fehler mit DALI-Server!\nLogs in: /var/log/daliserver.log",
            "dali_turn_on": "Licht während DALI-\nPrüfung nicht aktiviert!",
            "dali_turn_off": "Licht nach DALI-\nSignal nicht deaktiviert!",
            "external_switch_off": "Licht vor externem\nSchalten nicht deaktiviert!",
            "external_switch_turn_on": "Licht durch externen\nSchalter nicht aktiviert!",
        }

        gpio.red_light_on()
        gpio.deactivate_voltage()
        error_message = error_messages.get(error_code, "Ungültiger\nFehlercode!")
        self.save_error_protocol(error_message.replace("\n", " ").strip())
        self.error.label_text2.setText(error_message)
        self.main_window.setCurrentWidget(self.error)
        QApplication.processEvents()
        raise Exception

    # function for logout buttons
    def logout(self):
        if self.business_order_selection.pushButton_closeCover.isChecked():
            self.user_login.pushButton_closeCover.setChecked(True)
            self.business_order_selection.pushButton_closeCover.setChecked(False)
        if self.business_order_selection.pushButton_openCover.isChecked():
            self.user_login.pushButton_openCover.setChecked(True)
            self.business_order_selection.pushButton_openCover.setChecked(False)
        self.user_login.label_text2.hide()
        self.business_order_selection.label_text2.hide()
        self.business_order_selection.lineEdit_userInput.clear()
        self.article_selection.label_text2.hide()
        self.quantity_selection.label_text2.hide()
        self.quantity_selection.lineEdit1_userInput.clear()
        self.quantity_selection.lineEdit2_userInput.clear()
        self.quantity_selection.lineEdit2_userInput.setReadOnly(False)
        self.main_window.setCurrentWidget(self.user_login)
        self.user_login.lineEdit_userInput.setFocus()

    # function for app exit
    def exit_app(self):
        self.user_login.pushButton_openCover.setChecked(False)
        self.user_login.pushButton_closeCover.setChecked(False)
        self.close_to_exit = True
        self.main_window.setCurrentWidget(self.exit)

    def quit_app(self):
        gpio.cleanup()
        self.app.quit()


if __name__ == "__main__":
    tester = LightTester()
    tester.start()
